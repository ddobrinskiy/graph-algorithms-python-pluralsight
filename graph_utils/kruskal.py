# AUTOGENERATED! DO NOT EDIT! File to edit: 06_Kruskal_spanning_tree.ipynb (unless otherwise specified).

__all__ = ['spanning_tree', 'has_cycle']

# Cell
from queue import Queue
from typing import List, Dict
from collections import namedtuple

import graph_utils.core as gu
from .dijsktra import priority_dict

# Cell

def spanning_tree(graph:gu.Graph):
    sp_tree_is_found = False

    priority_queue = priority_dict()
    for v in range(graph.numVertices):
        for neighbor in graph.get_adjacent_vertices(v):
            priority_queue[(v, neighbor)] = graph.get_edge_weight(v, neighbor)

    visited_vertices = set()

    # maps node to adj nodes which are in the minimum spanning tree
    spanning_tree = dict()

    for v in range(graph.numVertices):
        spanning_tree[v] = set()

    # num of edjes we have so far
    num_edges = 0

    while len(priority_queue) and (num_edges < graph.numVertices - 1):
        v1, v2 = priority_queue.pop_smallest()

        if v1 in spanning_tree[v2]:
            continue

        vertex_pair = sorted([v1, v2])

        spanning_tree[vertex_pair[0]].add(vertex_pair[1])


        if has_cycle(spanning_tree):
            spanning_tree[vertex_pair[0]].remove(vertex_pair[1])
            continue

        num_edges -= 1

        visited_vertices.add(v1)
        visited_vertices.add(v2)

        print("Visited:", visited_vertices)

        if len(visited_vertices) != graph.numVertices:
            print('min spanning tree not found')
        else:
            print("min spanning tree:")
            for key in spanning_tree:
                for value in spanning_tree[key]:
                    print(key, "-->", value)
            sp_tree_is_found = True

    return sp_tree_is_found




# Cell
def has_cycle(spanning_tree):
    for source in spanning_tree:
        q = []
        q.append(source)

        visited_vertices = set()
        while q:
            vertex = q.pop(0)

            if vertex in visited_vertices:
                return True

            visited_vertices.add(vertex)
            q.extend(spanning_tree[vertex])

    return False