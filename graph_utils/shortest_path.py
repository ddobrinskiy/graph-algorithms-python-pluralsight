# AUTOGENERATED! DO NOT EDIT! File to edit: 03_shortest_path.ipynb (unless otherwise specified).

__all__ = ['Row', 'build_distance_table']

# Cell
from queue import Queue
from typing import List, Dict
from collections import namedtuple

import pandas as pd

import graph_utils.core as gu

# Cell
Row = namedtuple('Node', ['distance_from_source', 'preceding_vertex'])

# Cell
def _distance_table_to_df(distance_table:Dict):
    df = pd.DataFrame.from_dict(distance_table, orient='index')
    df.index.name = 'vertex_id'
    return df

# Cell
def build_distance_table(graph:gu.Graph, source:int):
    distance_table = dict()

    # initiate an empty distance table
    for i in range(graph.numVertices):
        #distance_table[i] = Row(distance_from_source=None, preceding_vertex=None)
        distance_table[i] = Row(None, None)

    # distance to the source from itself is 0
    distance_table[source] = Row(0, source)

    queue = Queue()
    queue.put(source)

    while not queue.empty():
        current_vertex = queue.get()

        # the distance of current vertex from the source
        current_distance = distance_table[current_vertex][0] # zero is index of distance

        for neighbor in graph.get_adjacent_vertices(current_vertex):
            # only update dist table if no current distance from the source is set
            neigbor_was_visited = distance_table[neighbor][0] is not None
            if not neigbor_was_visited:
                distance_table[neighbor] = Row(current_distance + 1, current_vertex)

                # enqueue the neigbor only if in has other adjacent vertices to explore
                if len(graph.get_adjacent_vertices(neighbor)):
                    queue.put(neighbor)





    return distance_table