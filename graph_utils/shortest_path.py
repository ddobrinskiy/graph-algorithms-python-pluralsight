# AUTOGENERATED! DO NOT EDIT! File to edit: 03_shortest_path.ipynb (unless otherwise specified).

__all__ = ['Row', 'build_distance_table', 'shortest_path']

# Cell
from queue import Queue
from typing import List, Dict
from collections import namedtuple

import pandas as pd

import graph_utils.core as gu

# Cell
Row = namedtuple('Node', ['distance_from_source', 'preceding_vertex'])

# Cell
def _distance_table_to_df(distance_table:Dict):
    df = pd.DataFrame.from_dict(distance_table, orient='index')
    df.index.name = 'vertex_id'
    return df

# Cell
def build_distance_table(graph:gu.Graph, source:int):
    distance_table = dict()

    # initiate an empty distance table
    for i in range(graph.numVertices):
        #distance_table[i] = Row(distance_from_source=None, preceding_vertex=None)
        distance_table[i] = Row(None, None)

    # distance to the source from itself is 0
    distance_table[source] = Row(0, source)

    queue = Queue()
    queue.put(source)

    while not queue.empty():
        current_vertex = queue.get()

        # the distance of current vertex from the source
        current_distance = distance_table[current_vertex][0] # zero is index of distance

        for neighbor in graph.get_adjacent_vertices(current_vertex):
            # only update dist table if no current distance from the source is set
            neigbor_was_visited = distance_table[neighbor][0] is not None
            if not neigbor_was_visited:
                distance_table[neighbor] = Row(current_distance + 1, current_vertex)

                # enqueue the neigbor only if in has other adjacent vertices to explore
                if len(graph.get_adjacent_vertices(neighbor)):
                    queue.put(neighbor)





    return distance_table

# Cell

def shortest_path(graph:gu.Graph, source:int, destination:int, dist_table_func):
    distance_table = dist_table_func(graph, source)
    path = [destination]

    # distance_table is a dict, s.t
    #                       0                     1
    # key:int = Row(distance_from_source, preceding_vertex)

    previous_vertex = distance_table[destination][1]

    while previous_vertex is not None and previous_vertex is not source:
        path = [previous_vertex] + path
        previous_vertex = distance_table[previous_vertex][1]

    if previous_vertex is None:
        msg = 'There is no path from {} to {}'.format(source, destination)
        print(msg)
        return None
    else:
        path = [source] + path
        return path